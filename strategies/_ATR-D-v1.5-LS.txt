{-------------------------------------------------------------
 Strategy: Buy & Hold with ATR Trailing Stop - BiDirectional Floating Entry
 Version: 1.5 (BiDirectional - Cap-on-Entry + Entry Ratchet)
 Date: 2026-01-08
 Platform: TradeStation EasyLanguage
 Timeframe: Daily bars

 Description: BIDIRECTIONAL buy-and-hold strategy with intelligent
              trailing stop management and floating entry levels.
              Uses ATR-based trailing stops with Bollinger Band
              volatility tightening. Entry via floating buy/sell-if-touched
              levels with EMA smoothed ATR buffer.

 Key Features:
 - BIDIRECTIONAL (long and short positions)
 - Configurable entry modes (flat only, long priority, full bidir)
 - ATR trailing stop (server-side via SetDollarTrailing)
 - BB tightening: Contracts stop during low volatility
 - Multiple scaling methods: Linear, Square Root, Exponential
 - Floating Entry: BuyTouchLevel = Close + (ATR_EMA × Multiplier)
 - Floating Entry: SellTouchLevel = Close - (ATR_EMA × Multiplier)
 - EMA smoothing reduces ATR whipsaws while staying responsive
 - Entry levels recalculated every bar when flat

 Entry Modes (Configurable via Entry_Mode input):

 MODE 0 - Symmetric (Flat Only):
 - Long:  Can enter ONLY from flat
 - Short: Can enter ONLY from flat
 - Both directions require position exit before new entry
 - Most conservative, avoids flip whipsaws
 - Best for: Choppy markets, risk-averse traders

 MODE 1 - Long Priority (Default):
 - Long:  Can enter from flat OR flip from short immediately
 - Short: Can enter ONLY from flat (never flip from long)
 - Asymmetric bias favoring upside
 - Long signals have priority
 - Best for: Bull markets, leveraged long ETFs (TQQQ, UPRO)
 - Rationale: Markets trend up long-term, leveraged ETF upward bias

 MODE 2 - Full Bidirectional:
 - Long:  Can enter from flat OR flip from short immediately
 - Short: Can enter from flat OR flip from long immediately
 - Symmetric aggressive flipping
 - Both directions treated equally
 - Best for: Range-bound markets, mean reversion strategies
 - Warning: Higher whipsaw risk, more transaction costs

 Trend Veto Filter for Flat Entry:
 When BOTH long and short are possible (flat position, both directions allowed):
 - Uses Trend_Filter_Period EMA slope as a VETO, not a choice
 - DEFAULT: Place LONG order (bull market bias for leveraged ETFs)
 - VETO: Only allow SHORT if slope < -Trend_Veto_Threshold (strong downtrend)
 - Threshold prevents daily noise from triggering shorts

 Logic:
 - Slope >= -Threshold: Place LONG (default, filters out weak downtrends)
 - Slope < -Threshold: Place SHORT (only on strong downtrends)

 Both_Triggered_Mode (Tiebreaker when Trend_Slope = 0):
 MODE 0 - Long Priority (Default):
 - Place LONG order when trend is perfectly flat
 - Favors upside in ambiguous situations

 MODE 1 - Skip Both:
 - Skip BOTH orders when trend is perfectly flat
 - Waits for trend to establish clear direction

 Entry Signals:
 - Long: Buy-If-Touched above floating level
 - Short: Sell-If-Touched below floating level
 - BuyTouchLevel = Close + (ATR_EMA × ATRBuyMultiplier)
 - SellTouchLevel = Close - (ATR_EMA × ATRBuyMultiplier)
 - Entry_Ratchet=0 (default): Recalculates every bar (floats with price)
 - Entry_Ratchet=1: BuyTouch only lowers, SellTouch only raises (catches slow drifts)
 - Independent ATR period and smoothing for entry
 - EMA smoothing (default 5 bars) filters noise while maintaining responsiveness

 Exit Signals:
 - ATR trailing stop hit (tightened by BB when volatility contracts)
 - NO OTHER EXIT CONDITIONS (always in market or waiting for re-entry)

 Position Sizing:
 - P/L reinvestment based on cumulative performance
--------------------------------------------------------------}

Inputs:
	Name("Your strategy name")	  [DisplayName = "Displays in Strategy Name Column for ID"],
    InitialInvestment(10000)      [DisplayName = "Initial Capital ($)"],
    RunLive(false)                [DisplayName = "Run Live Mode (Baseline P/L)"],

    // ATR Trailing Stop Parameters
    ATR_Period(14)                [DisplayName = "[4-70][1] ATR Period (Stop Loss)"],
    ATR_Multiplier(2.0)           [DisplayName = "[1-30][.25] ATR Multiplier (Stop Distance)"],
    Short_Multiplier(1.0)         [DisplayName = "[.2-1][.1] Short Exit Multiplier"],

    // Bollinger Band Tightening Parameters
    BB_Length(20)                 [DisplayName = "[6-70][2] BB Length (Volatility)"],
    BB_Deviation(2.0)             [DisplayName = "[1-4][.25] BB Std Deviations"],
    Vol_Threshold(0.10)           [DisplayName = "[.02-.4][.02] BB Width Threshold (Tightening)"],
    Min_Tightening(0.10)          [DisplayName = "[.1-.95][.05] Min Tightening Multiplier"],

    // Scaling Method for BB Tightening
    Scaling_Method(0)             [DisplayName = "[0-2][1] BB Scaling Method (0=Lin,1=Sqrt,2=Exp)"],

    // Re-Entry Parameters (Floating with EMA Smoothed ATR)
    ATRBuy_Period(14)             [DisplayName = "[4-70][1] ATR Period (Entry)"],
    ATRBuyMultiplier(2.0)         [DisplayName = "[.5-20][.25] ATR Multiplier (Entry Buffer)"],
    ATR_Smooth_Period(5)          [DisplayName = "[1-20][1] ATR EMA Smoothing Period"],
    // Entry_Ratchet hardcoded to 0 (Float mode) - removed from optimization grid
    // Analysis showed Entry_Ratchet=0 consistently outperformed in all v1.5 optimizations
    // while doubling grid size (100% increase). Keeping code for manual testing if needed.
    Entry_Ratchet(0)              [DisplayName = "Entry Ratchet (HARDCODED=0, not optimized)"],

    // Entry Flip Behavior
    Entry_Mode(1)                 [DisplayName = "[0-2][1] Entry Mode (0=Flat,1=LongPri,2=FullBiDir)"],

    // Trend Filter for Flat Entry (when both long and short are possible)
    Trend_Filter_Period(5)        [DisplayName = "[3-20][1] Trend Filter Period (Flat Entry)"],
    Trend_Veto_Threshold(0.05)    [DisplayName = "[-.5-.5][.1] Trend Slope Veto Threshold"],

    // Dual Entry Resolution (when both long and short could trigger when flat)
    Both_Triggered_Mode(0)        [DisplayName = "[0-1][1] Both Trigger Mode (0=LongPri,1=Skip)"],

    // Price Selection for Calculations
    EquityPrice_Method(0)         [DisplayName = "[0-1][1] Price Method (0=TypicalPrice,1=Close)"],

    // Trading Options
    EnableLongTrades(true)        [DisplayName = "Enable Long Positions"],
    EnableShortTrades(true)       [DisplayName = "Enable Short Positions"],

    PrintTesting(false)           [DisplayName = "Enable Debug Output"];

Variables:
    // Price Calculation
    CurrentPrice(0),
    HL2(0),

    // ATR and Stop Management
    ATR_Value(0),
    ATR_Period_Short(0),
    ATR_Value_Short(0),
    BasicStop(0),
    FinalStop_Long(0),
    FinalStop_Short(0),
    StopDistance(0),
    TrailAmtPerShare(0),

    // Bollinger Band Volatility
    BB_Width(0),
    BB_Multiplier(1.0),

    // Opening Stop Protection (4x 70-day ATR cap)
    ATR_Baseline(0),
    MaxStopDistance(0),
    ATR_Stop_Distance(0),

    // Re-Entry with EMA Smoothed ATR
    ATRBuy_Value(0),
    double ATR_Entry_Smooth(0),
    BuyTouchLevel(0),
    SellTouchLevel(0),
    NewBuyTouchLevel(0),
    NewSellTouchLevel(0),

    // Trend Filter for Flat Entry
    double Trend_EMA(0),
    double Trend_Slope(0),

    // Entry control flags
    bool AllowLongEntry(false),
    bool AllowShortEntry(false),
    bool BothTriggered(false),
    bool PlaceLong(false),
    bool PlaceShort(false),

    // P/L Reinvestment Variables
    EffNP(0),
    BaseNP(0),
    BaseTT(0),
    bool BaselineSet(false),
    bool InRealTime(false),
    CapitalForNextTrade(0),
    SharesToBuy(0),

    // Tracking
    PrevMarketPosition(0),

    // Debug
    string printableDate(""),
    string ScalingMethodName(""),
    string PriceMethodName(""),
    string EntryModeName(""),
    string BothTriggeredModeName(""),
    string TrendDirectionName("");

// CRITICAL: Tell TradeStation trail amount is per SHARE, not total position
once SetStopShare;

// -------------------------------------------------------------
// Initialize
// -------------------------------------------------------------
If CurrentBar = 1 then begin
    If Scaling_Method = 0 then
        ScalingMethodName = "Linear"
    else If Scaling_Method = 1 then
        ScalingMethodName = "SquareRoot"
    else If Scaling_Method = 2 then
        ScalingMethodName = "Exponential"
    else
        ScalingMethodName = "Unknown";

    If EquityPrice_Method = 0 then
        PriceMethodName = "TypicalPrice"
    else
        PriceMethodName = "Close";

    If Entry_Mode = 0 then
        EntryModeName = "Symmetric (Flat Only)"
    else If Entry_Mode = 1 then
        EntryModeName = "Long Priority"
    else If Entry_Mode = 2 then
        EntryModeName = "Full Bidirectional"
    else
        EntryModeName = "Unknown";

    If Both_Triggered_Mode = 0 then
        BothTriggeredModeName = "Long Priority"
    else If Both_Triggered_Mode = 1 then
        BothTriggeredModeName = "Skip Both"
    else
        BothTriggeredModeName = "Unknown";

    if PrintTesting then begin
        Print("BIDIRECTIONAL WITH CONFIGURABLE ENTRY MODES");
        Print("Price Method: ", PriceMethodName, " | BB Scaling: ", ScalingMethodName);
        Print("Entry Mode: ", Entry_Mode, " - ", EntryModeName);
        Print("Both Triggered: ", Both_Triggered_Mode, " - ", BothTriggeredModeName);
    end;
end;

// -------------------------------------------------------------
// Set Current Price based on method
// -------------------------------------------------------------
If EquityPrice_Method = 0 then
    CurrentPrice = TypicalPrice
else
    CurrentPrice = Close;

// Calculate HL2 for base stop (like SuperTrend)
HL2 = (High + Low) / 2;

// -------------------------------------------------------------
// Calculate ATR for Stop Loss
// -------------------------------------------------------------
If CurrentBar > ATR_Period then
    ATR_Value = AvgTrueRange(ATR_Period)
else
    ATR_Value = 0;

// -------------------------------------------------------------
// Calculate ATR for Short Exits (scaled period and multiplier)
// -------------------------------------------------------------
ATR_Period_Short = Round(ATR_Period * Short_Multiplier, 0);
If ATR_Period_Short < 1 then ATR_Period_Short = 1;

If CurrentBar > ATR_Period_Short then
    ATR_Value_Short = AvgTrueRange(ATR_Period_Short)
else
    ATR_Value_Short = 0;

// -------------------------------------------------------------
// Calculate ATR Baseline for Opening Stop Protection
// Cap at 4x 70-day ATR to limit opening risk during volatility spikes
// This protection fades as trailing stop tightens via BB
// -------------------------------------------------------------
If CurrentBar > 70 then begin
    ATR_Baseline = AvgTrueRange(70);
    MaxStopDistance = ATR_Baseline * 4;
end
else begin
    ATR_Baseline = 0;
    MaxStopDistance = 0;
end;

// -------------------------------------------------------------
// Calculate Bollinger Band Width
// -------------------------------------------------------------
If CurrentBar > BB_Length then begin
    // CRITICAL: BollingerBandWidth requires a price SERIES with historical data
    // NumDevsDown must be NEGATIVE (despite what manual says - function code is correct)
    BB_Width = BollingerBandWidth(Close, BB_Length, BB_Deviation, -BB_Deviation);
end
else
    BB_Width = 0;

// -------------------------------------------------------------
// Calculate ATR for Buy-If-Touched Re-Entry (independent period)
// -------------------------------------------------------------
If CurrentBar > ATRBuy_Period then
    ATRBuy_Value = AvgTrueRange(ATRBuy_Period)
else
    ATRBuy_Value = 0;

// -------------------------------------------------------------
// Smooth ATR with EMA for Entry
// -------------------------------------------------------------
If ATRBuy_Value > 0 then
    ATR_Entry_Smooth = XAverage(ATRBuy_Value, ATR_Smooth_Period)
else
    ATR_Entry_Smooth = 0;

// -------------------------------------------------------------
// Calculate Trend Filter EMA and Slope
// Used to determine which direction to enter when flat
// -------------------------------------------------------------
If CurrentBar > Trend_Filter_Period then begin
    Trend_EMA = XAverage(Close, Trend_Filter_Period);
    Trend_Slope = Trend_EMA - Trend_EMA[1];  // Positive = uptrend, Negative = downtrend

    // Determine trend direction name
    If Trend_Slope > 0 then
        TrendDirectionName = "UP"
    else If Trend_Slope < 0 then
        TrendDirectionName = "DOWN"
    else
        TrendDirectionName = "FLAT";

    if PrintTesting and mod(CurrentBar, 20) = 0 then begin
        printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
        Print(printableDate, " TREND FILTER: EMA(", Trend_Filter_Period, ")=", Trend_EMA:0:2,
              " Slope=", Trend_Slope:0:4, " (", TrendDirectionName, ")");
    end;
end
else begin
    Trend_EMA = 0;
    Trend_Slope = 0;
    TrendDirectionName = "N/A";
end;

// -------------------------------------------------------------
// Calculate Floating Buy/Sell-If-Touched Levels (Original Formula + EMA)
// CRITICAL: Must calculate levels based on what positions are ALLOWED, not just flat
// Mode 1: Long can flip from short, so calculate BuyTouch even when short
// Mode 2: Both can flip, so calculate both levels when in either position
// Entry_Ratchet=0: Recalculates every bar (floats with price)
// Entry_Ratchet=1: Only lowers BuyTouch / only raises SellTouch (catches slow drifts)
// -------------------------------------------------------------
If ATR_Entry_Smooth > 0 then begin
    // Calculate BuyTouchLevel if:
    // - Flat (all modes), OR
    // - Short and can flip to long (Mode 1 or 2)
    If MarketPosition = 0 or
       (MarketPosition = -1 and (Entry_Mode = 1 or Entry_Mode = 2)) then begin
        NewBuyTouchLevel = Close + (ATR_Entry_Smooth * ATRBuyMultiplier);

        If Entry_Ratchet = 0 then begin
            // Floating mode: always use new calculated level
            BuyTouchLevel = NewBuyTouchLevel;
        end
        else begin
            // Ratchet mode: only lower, never raise
            If BuyTouchLevel = 0 or NewBuyTouchLevel < BuyTouchLevel then
                BuyTouchLevel = NewBuyTouchLevel;
        end;
    end
    else begin
        BuyTouchLevel = 0;  // Not allowed to enter long
    end;

    // Calculate SellTouchLevel if:
    // - Flat (all modes), OR
    // - Long and can flip to short (Mode 2 only)
    If MarketPosition = 0 or
       (MarketPosition = 1 and Entry_Mode = 2) then begin
        NewSellTouchLevel = Close - (ATR_Entry_Smooth * ATRBuyMultiplier);

        If Entry_Ratchet = 0 then begin
            // Floating mode: always use new calculated level
            SellTouchLevel = NewSellTouchLevel;
        end
        else begin
            // Ratchet mode: only raise, never lower (inverse of long)
            If SellTouchLevel = 0 or NewSellTouchLevel > SellTouchLevel then
                SellTouchLevel = NewSellTouchLevel;
        end;
    end
    else begin
        SellTouchLevel = 0;  // Not allowed to enter short
    end;

    if PrintTesting and (BuyTouchLevel > 0 or SellTouchLevel > 0) then begin
        printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
        Print(printableDate, " Entry Levels (Mode ", Entry_Mode, ", MP=", MarketPosition,
              ", Ratchet=", Entry_Ratchet, "):");
        If BuyTouchLevel > 0 then
            Print("  BuyTouch=", BuyTouchLevel:0:2, " [New=", NewBuyTouchLevel:0:2, "]");
        If SellTouchLevel > 0 then
            Print("  SellTouch=", SellTouchLevel:0:2, " [New=", NewSellTouchLevel:0:2, "]");
        Print("  (Close=", Close:0:2, " ± ATR_EMA=", ATR_Entry_Smooth:0:3,
              " × ", ATRBuyMultiplier:0:2, ")");
    end;
end
else begin
    BuyTouchLevel = 0;
    SellTouchLevel = 0;
end;

// -------------------------------------------------------------
// Calculate BB Multiplier for Stop Tightening
// Uses different scaling methods
// -------------------------------------------------------------
If BB_Width >= Vol_Threshold then begin
    // Normal volatility: No tightening
    BB_Multiplier = 1.0;
end
else begin
    // Low volatility: Apply tightening based on scaling method

    // METHOD 0: LINEAR SCALING (Original)
    If Scaling_Method = 0 then begin
        BB_Multiplier = BB_Width / Vol_Threshold;
    end;

    // METHOD 1: SQUARE ROOT SCALING (Gentler)
    If Scaling_Method = 1 then begin
        BB_Multiplier = SquareRoot(BB_Width / Vol_Threshold);
    end;

    // METHOD 2: EXPONENTIAL SCALING (More Aggressive)
    If Scaling_Method = 2 then begin
        BB_Multiplier = Square(BB_Width / Vol_Threshold);
    end;

    // Apply minimum to prevent over-tightening
    If BB_Multiplier < Min_Tightening then
        BB_Multiplier = Min_Tightening;
end;

if PrintTesting and BB_Multiplier < 1.0 then begin
    printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
    Print(printableDate, " BB TIGHTENING (", ScalingMethodName, "): BBWidth=", BB_Width:0:4,
          " Threshold=", Vol_Threshold:0:2, " Multiplier=", BB_Multiplier:0:3);
end;

// -------------------------------------------------------------
// Baseline Logic (RunLive mode)
// -------------------------------------------------------------
InRealTime = (GetAppInfo(aiRealTimeCalc) = 1);

If RunLive then begin
    If InRealTime and not BaselineSet then begin
        if PrintTesting then
            Print("REALTIME BASELINE SET: NetProfit=", NetProfit, " TotalTrades=", TotalTrades);
        BaseNP = NetProfit;
        BaseTT = TotalTrades;
        BaselineSet = true;
    end;

    If BaselineSet then begin
        EffNP = NetProfit - BaseNP;
        If TotalTrades <= BaseTT then
            EffNP = 0;
    end
    else begin
        EffNP = -InitialInvestment;
    end;
end
else begin
    EffNP = NetProfit;
end;

// -------------------------------------------------------------
// Capital & Position Sizing
// -------------------------------------------------------------
CapitalForNextTrade = InitialInvestment + EffNP;

If CapitalForNextTrade < 0 then
    CapitalForNextTrade = 0;

If Close > 0 then
    SharesToBuy = IntPortion(CapitalForNextTrade / Close)
else
    SharesToBuy = 0;

If SharesToBuy < 0 then
    SharesToBuy = 0;

// -------------------------------------------------------------
// ENTRY LOGIC: Configurable Flip Behavior via Entry_Mode
// Mode 0: Symmetric - Both require flat
// Mode 1: Long Priority - Long flips from short, short needs flat
// Mode 2: Full BiDir - Both can flip from opposite position
//
// TREND VETO FILTER:
// When both long and short are possible (flat, both enabled):
// - Uses Trend_Filter_Period EMA slope as VETO, not choice
// - DEFAULT: LONG (bull market bias)
// - VETO: Only allow SHORT if slope < -Trend_Veto_Threshold
// - Prevents daily noise from causing shorts in bull markets
// -------------------------------------------------------------
If CurrentBar > MaxList(ATR_Period, ATRBuy_Period) and ATR_Value > 0 and ATRBuy_Value > 0 and SharesToBuy > 0 then begin

    // ==========================================================
    // STEP 1: Determine if long/short entries are allowed
    // ==========================================================
    // Reset entry control flags
    AllowLongEntry = false;
    AllowShortEntry = false;
    BothTriggered = false;
    PlaceLong = false;
    PlaceShort = false;

    // Long entry conditions based on Entry_Mode
    If Entry_Mode = 0 then begin
        // MODE 0: Symmetric - Long only from flat
        AllowLongEntry = (MarketPosition = 0);
    end
    else If Entry_Mode = 1 or Entry_Mode = 2 then begin
        // MODE 1 & 2: Long can flip from short
        AllowLongEntry = (MarketPosition <= 0);
    end;

    // Short entry conditions based on Entry_Mode
    If Entry_Mode = 0 or Entry_Mode = 1 then begin
        // MODE 0 & 1: Short only from flat
        AllowShortEntry = (MarketPosition = 0);
    end
    else If Entry_Mode = 2 then begin
        // MODE 2: Short can flip from long
        AllowShortEntry = (MarketPosition >= 0);
    end;

    // ==========================================================
    // STEP 2: Check if BOTH directions are possible (when flat)
    // Use TREND VETO FILTER to decide which order to place
    // ==========================================================
    BothTriggered = (EnableLongTrades and BuyTouchLevel > 0 and AllowLongEntry and
                     EnableShortTrades and SellTouchLevel > 0 and AllowShortEntry);

    // Resolve using Trend Veto Filter (default to LONG)
    If BothTriggered then begin
        // Both directions possible - use trend slope as VETO
        // DEFAULT: LONG (bull market bias)
        // VETO: Only allow SHORT if slope < -Trend_Veto_Threshold (strong downtrend)

        If Trend_Slope < -Trend_Veto_Threshold then begin
            // STRONG DOWNTREND: Veto long, allow short
            PlaceLong = false;
            PlaceShort = true;

            if PrintTesting then begin
                printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                Print(printableDate, " *** BOTH POSSIBLE - STRONG DOWNTREND - VETO LONG, ALLOW SHORT ***");
                Print("  Trend_Slope=", Trend_Slope:0:4, " < -Threshold(", -Trend_Veto_Threshold:0:4, ")");
                Print("  BuyTouch=", BuyTouchLevel:0:2, " SellTouch=", SellTouchLevel:0:2);
            end;
        end
        else If Trend_Slope = -Trend_Veto_Threshold then begin
            // EXACTLY AT THRESHOLD (rare): Use Both_Triggered_Mode as tiebreaker
            If Both_Triggered_Mode = 0 then begin
                // MODE 0: Long Priority
                PlaceLong = true;
                PlaceShort = false;

                if PrintTesting then begin
                    printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                    Print(printableDate, " *** BOTH POSSIBLE - AT THRESHOLD - LONG PRIORITY ***");
                    Print("  Trend_Slope=", Trend_Slope:0:4, " = -Threshold(", -Trend_Veto_Threshold:0:4, ")");
                    Print("  BuyTouch=", BuyTouchLevel:0:2, " SellTouch=", SellTouchLevel:0:2);
                end;
            end
            else If Both_Triggered_Mode = 1 then begin
                // MODE 1: Skip Both
                PlaceLong = false;
                PlaceShort = false;

                if PrintTesting then begin
                    printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                    Print(printableDate, " *** BOTH POSSIBLE - AT THRESHOLD - SKIPPING BOTH ***");
                    Print("  Trend_Slope=", Trend_Slope:0:4, " = -Threshold(", -Trend_Veto_Threshold:0:4, ")");
                    Print("  BuyTouch=", BuyTouchLevel:0:2, " SellTouch=", SellTouchLevel:0:2);
                    Print("  Waiting for clearer trend direction");
                end;
            end;
        end
        else begin
            // NOT STRONG DOWNTREND (default): Allow long, veto short
            PlaceLong = true;
            PlaceShort = false;

            if PrintTesting then begin
                printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                Print(printableDate, " *** BOTH POSSIBLE - DEFAULT TO LONG (VETO SHORT) ***");
                Print("  Trend_Slope=", Trend_Slope:0:4, " >= -Threshold(", -Trend_Veto_Threshold:0:4, ")");
                Print("  BuyTouch=", BuyTouchLevel:0:2, " SellTouch=", SellTouchLevel:0:2);
            end;
        end;
    end
    else begin
        // Only one direction possible - place that order
        PlaceLong = (EnableLongTrades and BuyTouchLevel > 0 and AllowLongEntry);
        PlaceShort = (EnableShortTrades and SellTouchLevel > 0 and AllowShortEntry);
    end;

    // ==========================================================
    // STEP 3: LONG ENTRY - Place order if PlaceLong is true
    // ==========================================================
    If PlaceLong and SharesToBuy > 0 then begin
        // If currently short, cover first (Mode 1 or 2)
        If MarketPosition = -1 then begin
            BuyToCover ("SX-FlipLong") Next Bar at Market;

            if PrintTesting then begin
                printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                Print(printableDate, " *** FLIPPING SHORT → LONG (Mode ", Entry_Mode, ") ***");
                Print("     Covering short at market, entering long at ", BuyTouchLevel:0:2);
            end;
        end;

        // Enter long at buy-if-touched level
        Buy ("LE-BuyTouch") SharesToBuy shares Next Bar at BuyTouchLevel Stop;

        // CRITICAL: Set initial stop for entry bar
        // Apply opening stop protection: cap at 4x 70-day ATR
        ATR_Stop_Distance = ATR_Value * ATR_Multiplier;
        If MaxStopDistance > 0 and ATR_Stop_Distance > MaxStopDistance then
            ATR_Stop_Distance = MaxStopDistance;
        BasicStop = HL2 - ATR_Stop_Distance;
        FinalStop_Long = BasicStop;
        TrailAmtPerShare = Close - BasicStop;

        If TrailAmtPerShare > 0 then
            SetDollarTrailing(TrailAmtPerShare);

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            If MarketPosition = 0 then
                Print(printableDate, " LONG ENTRY from FLAT (Mode ", Entry_Mode, ")")
            else If MarketPosition = -1 then
                Print(printableDate, " LONG ENTRY via FLIP from SHORT (Mode ", Entry_Mode, ")");
            Print(printableDate, " | Buy-If-Touched | Shares=", SharesToBuy,
                  " TouchLevel=", BuyTouchLevel:0:2);
            Print(printableDate, " [ENTRY] InitialStop=", BasicStop:0:2,
                  " TrailAmt=", TrailAmtPerShare:0:2);
        end;
    end;

    // ==========================================================
    // STEP 4: SHORT ENTRY - Place order if PlaceShort is true
    // ==========================================================
    If PlaceShort and SharesToBuy > 0 then begin
        // If currently long, exit first (Mode 2 only)
        If MarketPosition = 1 then begin
            Sell ("LX-FlipShort") Next Bar at Market;

            if PrintTesting then begin
                printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
                Print(printableDate, " *** FLIPPING LONG → SHORT (Mode 2 only) ***");
                Print("     Exiting long at market, entering short at ", SellTouchLevel:0:2);
            end;
        end;

        // Enter short at sell-if-touched level
        SellShort ("SE-SellTouch") SharesToBuy shares Next Bar at SellTouchLevel Stop;

        // CRITICAL: Set initial stop for entry bar (ABOVE price for shorts)
        // Uses scaled ATR for short exits
        // Apply opening stop protection: cap at 4x 70-day ATR
        ATR_Stop_Distance = ATR_Value_Short * ATR_Multiplier * Short_Multiplier;
        If MaxStopDistance > 0 and ATR_Stop_Distance > MaxStopDistance then
            ATR_Stop_Distance = MaxStopDistance;
        BasicStop = HL2 + ATR_Stop_Distance;
        FinalStop_Short = BasicStop;
        TrailAmtPerShare = BasicStop - Close;

        If TrailAmtPerShare > 0 then
            SetDollarTrailing(TrailAmtPerShare);

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            If MarketPosition = 0 then
                Print(printableDate, " SHORT ENTRY from FLAT (Mode ", Entry_Mode, ")")
            else If MarketPosition = 1 then
                Print(printableDate, " SHORT ENTRY via FLIP from LONG (Mode 2 only)");
            Print(printableDate, " | Sell-If-Touched | Shares=", SharesToBuy,
                  " TouchLevel=", SellTouchLevel:0:2);
            Print(printableDate, " [ENTRY] InitialStop=", BasicStop:0:2,
                  " TrailAmt=", TrailAmtPerShare:0:2);
        end;
    end;

end;

// -------------------------------------------------------------
// STOP LOSS MANAGEMENT: ATR Trailing with BB Tightening
// Uses SetDollarTrailing for server-side execution
// -------------------------------------------------------------

// LONG Position Stop
If MarketPosition = 1 and ATR_Value > 0 then begin
    // NO cap here - cap only applies at entry to limit initial risk
    // Wide stops are allowed during position to avoid premature exits
    BasicStop = HL2 - (ATR_Value * ATR_Multiplier);

    if PrintTesting then begin
        printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
        Print(printableDate, " [LONG DEBUG] HL2=", HL2:0:2, " ATR=", ATR_Value:0:3,
              " Multiplier=", ATR_Multiplier:0:2, " BasicStop=", BasicStop:0:2);
    end;

    If FinalStop_Long = 0 then begin
        FinalStop_Long = BasicStop;
        if PrintTesting then
            Print(printableDate, " [LONG DEBUG] INITIALIZING FinalStop_Long=", FinalStop_Long:0:2);
    end
    else If BasicStop > FinalStop_Long then begin
        if PrintTesting then
            Print(printableDate, " [LONG DEBUG] TRAILING UP: Old=", FinalStop_Long:0:2,
                  " New=", BasicStop:0:2, " Diff=", (BasicStop - FinalStop_Long):0:2);
        FinalStop_Long = BasicStop;
    end
    else begin
        if PrintTesting then
            Print(printableDate, " [LONG DEBUG] HOLDING: FinalStop=", FinalStop_Long:0:2,
                  " BasicStop=", BasicStop:0:2, " (not trailing)");
    end;

    StopDistance = Close - FinalStop_Long;

    if PrintTesting then begin
        Print(printableDate, " [LONG DEBUG] Close=", Close:0:2, " FinalStop=", FinalStop_Long:0:2,
              " StopDistance=", StopDistance:0:2);
    end;

    TrailAmtPerShare = StopDistance * BB_Multiplier;

    if PrintTesting then begin
        Print(printableDate, " [LONG DEBUG] FINAL: StopDistance=", StopDistance:0:2,
              " × BB_Mult=", BB_Multiplier:0:3, " = TrailAmt=", TrailAmtPerShare:0:2);
    end;

    If TrailAmtPerShare < 0 then begin
        Sell ("LX-StopBreach") Next Bar at Market;

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            Print(printableDate, " ***** LONG STOP BREACHED! Close=", Close:0:2,
                  " FinalStop=", FinalStop_Long:0:2, " EXITING AT MARKET *****");
        end;
    end
    else begin
        SetDollarTrailing(TrailAmtPerShare);

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            Print(printableDate, " LONG STOP: Close=", Close:0:2, " FinalStop=", FinalStop_Long:0:2,
                  " StopDistance=", StopDistance:0:2, " BBMult=", BB_Multiplier:0:3,
                  " TrailAmt=", TrailAmtPerShare:0:2);
        end;
    end;
end
else If MarketPosition <> 1 then begin
    FinalStop_Long = 0;
end;

// SHORT Position Stop (uses scaled ATR period and multiplier)
If MarketPosition = -1 and ATR_Value_Short > 0 then begin
    // NO cap here - cap only applies at entry to limit initial risk
    // Wide stops are allowed during position to avoid premature exits
    BasicStop = HL2 + (ATR_Value_Short * ATR_Multiplier * Short_Multiplier);

    if PrintTesting then begin
        printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
        Print(printableDate, " [SHORT DEBUG] HL2=", HL2:0:2, " ATR_Short=", ATR_Value_Short:0:3,
              " Multiplier=", (ATR_Multiplier * Short_Multiplier):0:2, " BasicStop=", BasicStop:0:2);
    end;

    If FinalStop_Short = 0 then begin
        FinalStop_Short = BasicStop;
        if PrintTesting then
            Print(printableDate, " [SHORT DEBUG] INITIALIZING FinalStop_Short=", FinalStop_Short:0:2);
    end
    else If BasicStop < FinalStop_Short then begin
        if PrintTesting then
            Print(printableDate, " [SHORT DEBUG] TRAILING DOWN: Old=", FinalStop_Short:0:2,
                  " New=", BasicStop:0:2, " Diff=", (FinalStop_Short - BasicStop):0:2);
        FinalStop_Short = BasicStop;
    end
    else begin
        if PrintTesting then
            Print(printableDate, " [SHORT DEBUG] HOLDING: FinalStop=", FinalStop_Short:0:2,
                  " BasicStop=", BasicStop:0:2, " (not trailing)");
    end;

    StopDistance = FinalStop_Short - Close;

    if PrintTesting then begin
        Print(printableDate, " [SHORT DEBUG] Close=", Close:0:2, " FinalStop=", FinalStop_Short:0:2,
              " StopDistance=", StopDistance:0:2);
    end;

    TrailAmtPerShare = StopDistance * BB_Multiplier;

    if PrintTesting then begin
        Print(printableDate, " [SHORT DEBUG] FINAL: StopDistance=", StopDistance:0:2,
              " × BB_Mult=", BB_Multiplier:0:3, " = TrailAmt=", TrailAmtPerShare:0:2);
    end;

    If TrailAmtPerShare < 0 then begin
        BuyToCover ("SX-StopBreach") Next Bar at Market;

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            Print(printableDate, " ***** SHORT STOP BREACHED! Close=", Close:0:2,
                  " FinalStop=", FinalStop_Short:0:2, " EXITING AT MARKET *****");
        end;
    end
    else begin
        SetDollarTrailing(TrailAmtPerShare);

        if PrintTesting then begin
            printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
            Print(printableDate, " SHORT STOP: Close=", Close:0:2, " FinalStop=", FinalStop_Short:0:2,
                  " StopDistance=", StopDistance:0:2, " BBMult=", BB_Multiplier:0:3,
                  " TrailAmt=", TrailAmtPerShare:0:2);
        end;
    end;
end
else If MarketPosition <> -1 then begin
    FinalStop_Short = 0;
end;

// -------------------------------------------------------------
// Debug Output
// -------------------------------------------------------------
if PrintTesting and mod(CurrentBar, 20) = 0 then begin
    printableDate = FormatDate("ddd MMM dd yy", ElDateToDateTime(Date));
    Print("========================================");
    Print(printableDate, " BIDIRECTIONAL STATUS");
    Print("Entry Mode: ", Entry_Mode, " - ", EntryModeName);
    Print("Trend Veto: EMA(", Trend_Filter_Period, ")=", Trend_EMA:0:2,
          " Slope=", Trend_Slope:0:4, " (", TrendDirectionName, ")");
    Print("Veto Threshold: ", -Trend_Veto_Threshold:0:4, " (shorts only if slope < threshold)");
    Print("Both Triggered Mode: ", Both_Triggered_Mode, " - ", BothTriggeredModeName);
    Print("ATR(", ATR_Period, ")=", ATR_Value:0:3, " Multiplier=", ATR_Multiplier:0:2);
    Print("BB Width=", BB_Width:0:4, " Threshold=", Vol_Threshold:0:2);
    Print("BB Multiplier=", BB_Multiplier:0:3, " (", ScalingMethodName, ")");
    Print("BuyTouchLevel=", BuyTouchLevel:0:2, " SellTouchLevel=", SellTouchLevel:0:2);
    Print("ATR_Raw=", ATRBuy_Value:0:3, " ATR_EMA=", ATR_Entry_Smooth:0:3);
    Print("ATRBuyMultiplier=", ATRBuyMultiplier:0:2, " Smooth_Period=", ATR_Smooth_Period);
    Print("Enabled: Long=", EnableLongTrades, " Short=", EnableShortTrades);
    Print("MarketPosition=", MarketPosition, " Capital=", CapitalForNextTrade:0:2);
    Print("========================================");
end;

// -------------------------------------------------------------
// Update Previous Position for Next Bar
// -------------------------------------------------------------
PrevMarketPosition = MarketPosition;

// -------------------------------------------------------------
// Close any open position at END OF OPTIMIZATION ONLY
// Safe for live trading and backtesting - only triggers during optimization
// -------------------------------------------------------------
If LastBarOnChart and GetAppInfo(aiOptimizing) = 1 then begin
    // We're on the last bar AND we're in optimization mode
    // This closes positions for accurate optimization P/L calculation

    If MarketPosition = 1 then
        Sell ("LX-EndOfTest") this bar on Close;
    If MarketPosition = -1 then
        BuyToCover ("SX-EndOfTest") this bar on Close;
end;

{-------------------------------------------------------------
 CHANGE LOG
--------------------------------------------------------------
 v1.4 (BiDirectional - Configurable Entry Modes) - 2025-12-15
 - BACKPORTED: Entry Mode system from DualS-LS variant
 - NEW: Entry_Mode input (0=Flat Only, 1=Long Priority, 2=Full BiDir)
 - NEW: Trend_Filter_Period input for EMA slope calculation
 - NEW: Trend_Veto_Threshold input (supports negative values)
 - NEW: Both_Triggered_Mode input for tiebreaker logic
 - NEW: Trend Veto Filter for flat entry decisions
   * DEFAULT: Place LONG orders (bull market bias for leveraged ETFs)
   * VETO: Only allow SHORT if slope < -Trend_Veto_Threshold
   * Prevents whipsaws from minor slope changes
 - NEW: Mode 1 allows long to flip from short position
 - NEW: Mode 2 allows both directions to flip
 - NEW: Entry level calculation considers Entry_Mode
   * Mode 1: BuyTouch calculated when flat OR short
   * Mode 2: Both levels calculated when in opposite position
 - NEW: Short_Multiplier input for tighter short exits
   * Scales both ATR_Period and ATR_Multiplier for short stops
   * Range 0.2-1.0 (1.0 = same as longs, 0.2 = very tight)
   * Separate ATR_Value_Short calculation with rounded period
 - Rationale: Same features as DualS-LS benefit single-symbol trading
   * Smarter flip behavior reduces whipsaws
   * Trend veto prevents false direction changes
   * Long priority suits leveraged long ETFs
   * Tighter short exits reduce drawdown in bull markets

 v1.4 (BiDirectional - Original Floating Entry with EMA Smoothed ATR) - 2025-11-21
 - RESTORED: Original floating entry formula (bidirectional)
 - NEW: EMA smoothing for ATR component (reduces whipsaws)
 - REMOVED: BB_Entry_Length and BB_Entry_Deviation inputs
 - REMOVED: BB_Entry_Upper, BB_Entry_Lower, BB_Entry_Avg, BB_Entry_StdDev variables
 - REMOVED: BB Breakout entry logic
 - ADDED: ATRBuy_Period, ATRBuyMultiplier, ATR_Smooth_Period inputs
 - ADDED: ATRBuy_Value, ATR_Entry_Smooth, BuyTouchLevel, SellTouchLevel variables
 - Entry formula: BuyTouchLevel = Close + (ATR_EMA × Multiplier)
 - Entry formula: SellTouchLevel = Close - (ATR_EMA × Multiplier)
 - ATR_Entry_Smooth = XAverage(ATRBuy_Value, ATR_Smooth_Period)
 - Default 5-bar EMA smoothing reduces ATR noise
 - Levels recalculated every bar when flat (floating behavior)
 - More stable entry levels while maintaining responsiveness
 - OCO orders: Buy-If-Touched above, Sell-If-Touched below
 - Maintains all stop loss and BB tightening functionality
 - Maintains EnableLongTrades and EnableShortTrades options

 v1.3 (BiDirectional - BB Break out Entry) - 2025-11-21
 - NEW: Bollinger Band Breakout Entry System (bidirectional)
 - REMOVED: Trailing floor/ceiling + breathing ATR entry mechanism
 - REMOVED: ATRBuy_Period and ATRBuyMultiplier inputs
 - REMOVED: TrailingFloorPrice, TrailingCeilingPrice, BuyTouchLevel, SellTouchLevel, ATRBuy_Value, JustWentFlat variables
 - ADDED: BB_Entry_Length and BB_Entry_Deviation inputs
 - ADDED: BB_Entry_Upper, BB_Entry_Lower, BB_Entry_Avg, BB_Entry_StdDev variables
 - LONG Entry: Close > BB_Entry_Upper (breakout above upper band)
 - SHORT Entry: Close < BB_Entry_Lower (breakdown below lower band)
 - Enters at market (no buy-if-touched/sell-if-touched levels)
 - Independent BB parameters allow entry/stop optimization
 - Simplified entry logic with dynamic BB-based filtering
 - Maintains all stop loss and BB tightening functionality
 - Maintains EnableLongTrades and EnableShortTrades options

 v1.2 (BiDirectional) - 2025-11-21
 - NEW: Trailing floor/ceiling + breathing ATR entry mechanism
 - TrailingFloorPrice tracks lowest close (for long entries)
 - TrailingCeilingPrice tracks highest close (for short entries)
 - Floor only moves DOWN, Ceiling only moves UP
 - BuyTouchLevel = Floor + (ATR × Mult) recalculated every bar
 - SellTouchLevel = Ceiling - (ATR × Mult) recalculated every bar
 - ATR components "breathe" with changing volatility
 - Provides dynamic filtering while maintaining discipline
 - Entry levels respond to both price AND volatility changes
 - Removed NewBuyLevel and NewSellLevel variables (no longer needed)

 v1.1 (BiDirectional) - 2025-11-19
 - FIXED: OCO re-entry levels now properly trail
 - BuyTouchLevel and SellTouchLevel are FIXED when position exits
 - BuyTouchLevel only trails DOWN as price drops (never chases up)
 - SellTouchLevel only trails UP as price rises (never chases down)
 - Added JustWentFlat detection for both long and short exits
 - TRUE bidirectional trailing: Both levels become more attractive
 - FIXED: Explicit boolean comparison for condition evaluation

 v1.0 (BiDirectional) - 2025-11-17
 - Initial implementation (bidirectional variant)
 - ATR-based trailing stop with SetDollarTrailing
 - BB tightening with 3 scaling methods (Linear/Sqrt/Exp)
 - OCO re-entry orders in both directions
--------------------------------------------------------------}
